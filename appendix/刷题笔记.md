# 刷题笔记

## 如何有效学习数据结构与算法？

### 如何精通一个领域？

* Chunk it up  切碎知识点

  将数据结构与算法的基本知识点分解开来，分解结果见：[数据结构与算法脑图]( http://naotu.baidu.com/file/cd094852bfc84ec5e1868867936451c3?token=ef906723267f2f9f )

* Deliberate Practicing 刻意练习

  对分解之后的知识点进行分解训练和反复练习。

  * 明白一个`原则`：基本功是区别业余和职业选手的根本，我们的目标是成为职业选手。

  * 明白一个`误区`：**刷一道算法题，刷一遍是完全不够的，需要一遍遍刷题**。
  * 明白一个`事实`：反复练习自己薄弱的地方，扩张舒适区，会让我们成长更快。 

* Feedback 反馈

  反馈对于学习的作用，主要是将揉碎的知识点再串联起来，形成体系结构，这样就建立了一个 `知识点-> 专项反复练习-> 建立知识体系`的学习闭环。

  * 即时反馈
  * 主动型反馈（自己去找）
    * 高手代码，例如 Github，LeetCode（题解、Discussion）
    * 第一视角直播
  * 被动式反馈（高手指点）
    * Code Review
    * 教练看你打，然后给你反馈

### 如何精通数据结构与算法呢？

> 如何反复刷题呢？答案是：五步刷题法，我们称为***五毒神掌***。

1. 刷题第***1***遍
   * 5分钟时间：读题+思考
   * 若5分钟思考不出来，直接看解法，要注意：**对每一道题目，思考和比较这个题的多种解法，最好是全部解法**
   * **背诵、默写好的解法**：这是积累代码能力的一个很好的办法。
2. 刷题第***2***遍
   * 马上自己写 -> LeetCode提交
   * **多种解法进行比较、体会 -> 优化**
3. 刷题第***3***遍
   * **一天后**，再重复做题
   * 针对不同解法的熟练程度 -> 对薄弱的地方进行专项练习
4. 刷题第***4***遍
   * **一周后**，反复回来练习相同的题目
5. 刷题第***5***遍
   * **面试前一周**进行恢复性训练。

> 如何刷一道题呢？ 答案是：**切题四件套**。

1.  Clarification: 多沟通，多思考，确保正确理解问题                     ***（面试的时候，和面试官过一遍题目）***
2. Possible solutions: 思考关于这个题目的所有解法，比较其优劣，优化其性能
   * compare(time/space)
   * optimal(加强)：例如空间换时间、升维（一维到二维）    ***（提出多种解法，给出最优解法）***
3. Coding: 就是不停的写，多写，提高Coding能力的唯一法宝       ***（代码实现）***
4. Test cases                                                                                            ***（阐述测试样例）***

## 工具

### [visualgo](https://visualgo.net/zh)

### [bigocheatsheet](https://www.bigocheatsheet.com/)

## 代码模板

### 递归代码模板 Recursion

* Python

  ```python
  def recursion(level, param1, param2, ...): 
      # terminator 
      if (level > MAX_LEVEL): 
  	   # process result 
  	   return 
  
      # process current logic
      process(level, data...) 
  
      # drill down 
      self.recursion(level + 1, p1, ...) 
  
      # restore the current level status if needed
  
  ```

* Java

  ```java
  public void recur(int level, int param) { 
    // terminator 
    if (level > MAX_LEVEL) { 
      // process result 
      return; 
    } 
  
    // process current logic 
    process(level, param); 
  
    // drill down 
    recur( level: level + 1, newParam); 
  
    // restore current status 
   
  }
  ```

  

### 分治代码模板 Divide and Conquer

```python
def divide_conquer(problem, param1, param2, ...): 
  # recursion terminator 
  if problem is None: 
	print_result 
	return 

  # prepare data 
  data = prepare_data(problem) 
  subproblems = split_problem(problem, data) 

  # conquer subproblems 
  subresult1 = self.divide_conquer(subproblems[0], p1, ...) 
  subresult2 = self.divide_conquer(subproblems[1], p1, ...) 
  subresult3 = self.divide_conquer(subproblems[2], p1, ...) 
  …

  # process and generate the final result 
  result = process_result(subresult1, subresult2, subresult3, …)
	
  # restore the current level states

```

### 查找-搜索-遍历 模板
查找的特点是：

* 找到特定元素

搜索的特点是：

* 每个节点都要访问一次
* 每个节点仅仅访问一次
* 每个节点访问顺序不限

#### 二分查找（Binary Search）

```python
left, right = 0, len(array) - 1
while left <= right:
    mid = (left + right) / 2
    if array[mid] == target:
        # find the target
        break or return result
    elif array[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

#### 深度优先搜索（DFS, Depth First Search)

```python
# 递归写法
visited = set()

def dfs(node, visited):
    # terminator
    if node in visited:
        return           # already visited
    
    visited.add(node)
    
    # process current node here
    for next_node in node.children():
        if not next_node in visited:
         	dfs(next_node, visited)
            
# 非递归写法
def DFS(self, tree):
    if tree.root is None:
        return []
    visited, stack = [], [tree.root]
   	
    while stack:
        node = stack.pop()
        visited.add(node)
        process(node)
        nodes = generate_realted_nodes(node)
        stack.push(nodes)
        
    # other processing work
    ...
   
```

#### 广度优先遍历（BFS, Breadth First Search）

```python
def BFS(graph, start, end):
    queue = []
    queue.append([start])
    visited.add(start)
    
    while queue:
        node = queue.pop()
        visited.add(node)
        process(node)
        nodes = generate_related_nodes(node)
        queue.push(nodes)
    
    # other processing work
    ...         
```



## Dynamic Programming

> Simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner



### 动态规划基本理论

#### 一个模型：多阶段决策最优解模型

动态规划一般用于解决最优问题。多阶段决策最优解模型是指动态规划适合解决的问题的模型。解决问题的过程需要经历多个决策过程，每个决策过程都对应着一组状态。动态规划的目标在于寻找一组决策序列（每个决策过程的状态），通过这组决策序列产生最终期望的求解的最优值。



#### 三个特征

##### 最优子结构

最优子结构是指问题的最优解包含子问题的最优解。我们可以通过子问题的最优解得到问题的最优解，也就是说，后面的状态可以通过前面的状态推导出来。

##### 无后效性

无后效性有两层含义：

* 在推导后面状态的时候，我们只关心前面阶段的状态值，而不关心这个状态值的求解过程；
* 某个阶段的状态一旦确定，就不受之后阶段的决策影响，即状态定了就定了。

##### 重复子问题

不同的决策序列，到达某个相同的阶段的时候，可能会产生重复的状态。 



#### 实例

> 问题：给定一个`n * n`的矩阵` w[n][n]`，矩阵存储的均为正整数。棋子从矩阵的左上角出发去右下角，每次只能向右或者是向下移动1位。从左上角到右下角有很多不同的路径可以走。规定每条路径经过的数字之和就是这条路径的长度。求从左上角到右下角的最短路径。

##### 分析：

***这个问题是否满足`一个模型`呢？***

从 `(0, 0)` 出发到 `(n-1, n-1)`，总计`2*(n-1)`步，对应着`2*(n-1)`个阶段，每个阶段都有向右或者向下2种决策，因此每个阶段都会对应一个状态集合。问题的目标在于找到一个状态序列，从而确定 `(0, 0)` 出发到 `(n-1, n-1)`的最短距离。因此整个问题是一个`多阶段决策最优解`问题。



***这个问题是否满足`三大特征`呢？***

对于任意一个节点`(i, j)`来说，从 `(0, 0)` 出发到 `(i, j)`存在多种路线，因此可能存在`重复子问题`。

对于任意一个节点`(i, j)`来说，`(i, j)`这个位置的状态需要通过 `(i-1, j)`以及 `(i, j-1)`两个位置的状态来确定，但是并不需要关心这2个位置的状态的求解过程。而且，由于仅仅允许向右或者向下运动，因此前面阶段的状态确定了之后，不会被后面的状态所改变，因此满足`无后效性`的特征。

定义状态为：`min_dist(i, j)`，表示从 `(0, 0)` 出发到 `(i, j)`的最短距离。那么到达`(i, j)`的最短路径必然经过`(i-1, j)`或 `(i, j-1)`，因此，到达`(i, j)`的最短路径必然包含到达这2个位置的最短路径之一。因此满足 `最优子结构` 的特征。

综上所述，`min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))`。

##### 求解:

```java
// 回溯算法
private int min = Integer.MAX_VALUE;
public void minDist(int i, int j, int dist, int[][] w, int n) {
    // terminator
    if (i == n && j == n) {
        if (dist < min) min = dist;
        return;
    }
    // drill down
    if (i < n) {
        minDist(i + 1, j, dist + w[i][j], w, n);
    }
    if (j < n) {
        minDist(i, j + 1, dist + w[i][j], w, n);
    }
}
```

```java
// 递归+备忘录（缓存）减少重复计算
private int[][] mem = new int[n][n];
public int minDist(int i, int j, int[][] w) {
    if (i == 0 && j == 0) {
        return w[0][0];
    }
    if (mem[i][j] > 0) {
        return mem[i][j];
    }
    int minLeft = Integer.MAX_VALUE;
    if (j-1>=0 ) {
        minLeft = minDist(i, j-1);
    }
    int minUp = Integer.MAX_VALUE;
    if (i-1>= 0) {
        minUp = minDist(i-1, j);
    }
    int curMinDist = w[i][j] + Math.min(minLeft, minUp);
    mem[i][j] = curMinDist;
    return curMinDist;
}
```

```java
// 动态规划
public int minDist(int[][] w, int n) {
    int[][] states = new int[n][n];
    int sum = 0;
    for (int j = 0; j < n; j++) {
        sum += w[0][j];
        states[0][j] = sum;
    }
    sum = 0;
    for (int i = 0; i < n; i++) {
        sum += w[i][0];
        states[i][0] = sum;
    }
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            states[i][j] = w[i][j] + Math.min(states[i][j-1], states[i-1][j]);
        }
    }
    return states[n-1][n-1];
}
```



### 一维动态规划：Fibnacci

```java
# 递归：自顶向下 O(2^N)
int fib(int n) {
    if (n <= 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2); // 改进：return n <= 1 ? n : fib(n-1) + fib(n-2);
}

# 递归 + 备忘录 （记忆化搜索） O(N)
int fib(int n, int[] memo) {
    if (n <= 1) {
        return n;
    }
    if (memo[n] == 0) {
        memo[n] = fib(n-1, memo) + fib(n-2, memo);
    }
    return memo[n];
}

# 动态规划：自底向上 O(N)
int fib(int n) {
    int[] dp = new int[n];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
   
# 一维的Equation: f(n) = f(n-1) + f(n-2)
```



### 二维动态规划：Count the paths

```java
// 递归
int countPaths(boolean[][] grid, int row, int col) {
    if (!validSqure(grid, row, col)) return 0;
    if (isAtEnd(grid, row, col)) return 1;
    return countPaths(grid, row + 1, col) + countPaths(grid, row, col+1);
}

opt[i, j] = opt[i+1, j] + opt[i, j+1];
if a[i, j] == '空地'：
    opt[i, j] = opt[i+1, j] + opt[i, j+1];
else: 
	opt[i, j] = 0;

对比：
# 一维的Equation: f(n) = f(n-1) + f(n-2)
    
# 二维的Equation: opt[i, j] = opt[i+1, j] + opt[i, j+1];
```



## 总结代码库（示例）

* Valid anagram

  ```python
  # 思路：手动模拟hashtable，将字符串”a-z“的ASCII码作key，计数求差异    
     def  isAnagram(self, s: str, t: str) -> bool:
          arr1, arr2 = [0]*26, [0]*26
          for i in s:
              arr1[ord(i) - ord('a')] += 1
          for i in t:
              arr2[ord(i) - ord('a')] += 1
          return arr1 == arr2
  # 思路：map计数，对比计数差异
      def isAnagram(self, s: str, t: str) -> bool:
          dict1, dict2 = {}, {}
          for item in s:
              dict1[item] = dict1.get(item,0) + 1
          for item in t:
              dict2[item] = dict2.get(item,0) + 1
          return dict1 == dict2
  # 思路：数组排序后比较差异
      def isAnagram(self, s: str, t: str) -> bool:
          return sorted(s) == sorted(t)
  ```

  ```java
  public class Solution {
      public boolean isAnagram(String s, String t) {
          if(s.length() != t.length()) return false;
          int [] a = new int [26];
          for(Character c : s.toCharArray()) a[c - 'a']++;
          for(Character c : t.toCharArray()) {
              if(a[c -'a'] == 0) return false;
              a[c - 'a']--;
          }
          return true;
      }
      
      public boolean isAnagram(String s1, String s2) {
          int[] freq = new int[256];
          for(int i = 0; i < s1.length(); i++) freq[s1.charAt(i)]++;
          for(int i = 0; i < s2.length(); i++) if(--freq[s2.charAt(i)] < 0) return false;
          return s1.length() == s2.length();
      }
      
      
  	public boolean isAnagram(String s, String t) {
      	char[] sChar = s.toCharArray();
      	char[] tChar = t.toCharArray();
      	Arrays.sort(sChar);
      	Arrays.sort(tChar);
      	return Arrays.equals(sChar, tChar);   
  	}
  }
  
  ```

*  Group Anagrams 

  ```python
  def groupAnagrams(self, strs):
      d = {}
      for w in sorted(strs):
          key = tuple(sorted(w))
          d[key] = d.get(key, []) + [w]
      return d.values()
  
  def groupAnagrams(self, strs):
      dic = {}
      for item in sorted(strs):
          sortedItem = ''.join(sorted(item))
          dic[sortedItem] = dic.get(sortedItem, []) + [item]
      return dic.values()
  ```

  ```java
  public List<List<String>> groupAnagrams(String[] strs) {
  	List<List<String>> res = new ArrayList<>();
      HashMap<String, List<String>> map = new HashMap<>();
      
      Arrays.sort(strs);
      for (int i = 0; i < strs.length; i++) {
      	String temp = strs[i];
      	char[] ch = temp.toCharArray();
      	Arrays.sort(ch);
      	if (map.containsKey(String.valueOf(ch))) {
      		map.get(String.valueOf(ch)).add(strs[i]);
      	} else {
      		List<String> each = new ArrayList<>();
      		each.add(strs[i]);
      		map.put(String.valueOf(ch), each);
      	}
      }
      for (List<String> item: map.values()) {
      	res.add(item);
      }
      return res;
  }
  ```

*  Two sum 

  ```python
  def twoSum(self, nums, target):
      d = dict()
      for index,num in enumerate(nums):
          if d.get(num) == None:
              d[target - num] = index
          else:
              return [d.get(num), index
  ```

  ```java
  public int[] twoSum(int[] nums, int target) {
      HashMap<Integer, Integer> tracker = new HashMap<Integer, Integer>();
      int len = nums.length;
      for (int i = 0; i < len; i++){
          if (tracker.containsKey(nums[i])){
              int left = tracker.get(nums[i]);
              return new int[]{left+1, i+1};
          } else {
              tracker.put(target - nums[i], i);
          }
      }
      return new int[2];
  }
  ```

  



## 刷题开始

### Array

#### 283. [move zeros]( https://leetcode-cn.com/problems/move-zeroes/ )

> 方法1：将所有的非零元素都填充到数组前侧，然后将0填充到数组后侧  `#双指针法`

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int lastNotZeroIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] != 0) {
                nums[lastNotZeroIndex++] = nums[i];
            }
        }
        
        for (int i = lastNotZeroIndex; i < nums.length; ++i) {
            nums[i] = 0;
        }
    }
}
```



> 方法2：一维数组的坐标转换  i, j  `#双指针法`
>
> 用 j 记录上一个可能为0的值的索引，用 i 遍历数组，当遇到不为0的值的时候，将该元素 num[i] 与 nums[j] 交换，保证 j 前面的元素均为非0值。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int lastZeroIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] != 0) {
                int temp = nums[i];
                nums[i] = nums[lastZeroIndex];
                nums[lastZeroIndex] = temp;
                lastZeroIndex++;
            }
        }
    }
}
```

#### 11. [container with most water]( https://leetcode-cn.com/problems/container-with-most-water/ )

> 思路：
>
> 1.`枚举`： left bar x, right bar y, (y - x) * min_height     O(n^2)    `#枚举`

```java
// 遍历数组的一个常见的办法:遍历左右边界，且左右边界不能重复
class Solution {
    public int maxArea(int[] a) {
        int max = 0
        for (int i = 0; < a.length - 1; ++i) {
            for (int j = i + 1; j < a.length; ++j) {
                int area = (j - i) * Math.min(a[i], a[j]);
                max = Math.max(max, area); 
            }
        }
        return max;
    }
}
```

> 2.`左右夹逼/双指针法`：左右边界 i, j, 向中间收敛                   `#双指针法：左右夹中间，中间到两边`

```java
// 遍历数组的一个常见的办法:遍历左右边界，且左右边界不能重复
class Solution {
    public int maxArea(int[] a) {
        int max = 0
        for (int i = 0, j = a.length - 1; i < j; ) {
            int minHeight = a[i] < a[j] ? a[i++] : a[j--];
            max = Math.max(max, (j - i + 1) * minHeight); 
        }
        return max;
    }
}
```

#### 70. [climbing stairs](https://leetcode-cn.com/problems/climbing-stairs/)

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n;
        int f1 = 1;
        int f2 = 2;
        int f3 = 3;
        for (int i = 3; i <= n; i++) {
            f3 = f1 + f2;
            f1 = f2;
            f2 = f1;
        }
        return f3;
    }
}
```

#### 1. [2sum](https://leetcode-cn.com/problems/two-sum/)

> 方法1：暴力解法 O(n^2)

```java
// 遍历数组的一个常见的办法:遍历左右边界，且左右边界不能重复
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length - 1; ++i) {
            for (int j = i + 1; j < nums.length; ++j) {
                if (nums[i] + nums[j] == target) {
					return new int[] {i, j};
                }
            }
        }
        return new int[2];
    }
}
```

> 方法2：两遍哈希表  
>
> 思想：空间换时间
>
> ***保持数组中的每个元素与其索引相互对应的最好方式是什么？ 哈希表。***
>
> 哈希表查找的时间复杂度为 O(1)。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            map.put(target - nums[i], i);
        }
        for (int i = 0; i < nums.length; ++i) {
            if (map.containsKey(nums[i]) && i != map.get(nums[i])) {
                return new int[] {i, map.get(nums[i])};
            }
        }
        return new int[2];
    } 
}
```

> 方法3：一遍哈希表
>
> 由于在遍历数组的过程中，可以回过头来查找哈希表中是否存储了目标元素的值，因此，没有必要遍历完整的数组将目标元素的值存储到哈希表中，可以边遍历边存储。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            int component = target - nums[i];
            if (map.containsKey(component)) {
                return new int[] {map.get(component), i};
            }
            map.put(nums[i], i);
        }
        return new int[2];
    } 
}
```



#### 15. [3sum](https://leetcode-cn.com/problems/3sum/)

> 思路：转化 a + b = -c
>
> 1.暴力解法：三重循环
>
> 2.HashMap
>
> 3.`左右夹逼/双指针法`，这种办法有时候需要排序。

### Linked List

#### 141.  [linked-list-cycle](https://leetcode.com/problems/linked-list-cycle) 

> 1.暴力解法：遍历链表，hash/set
>
> 2.`快慢指针 `                                                                            `#快慢指针法`



### Stack

#### 20. [valid parentheses](https://leetcode-cn.com/problems/valid-parentheses/description/)

> 为啥这个题目可以用栈解决？ 具有最近相关性
>
> 1.暴力解法：不断replace匹配的括号 -> "" O(n^2)
>
> a. (){}[]
>
> b.((({[]})))
>
> 2.Stack

#### 155. [min Stack](https://leetcode-cn.com/problems/min-stack/)

> `两个队列实现栈`
>
> `两个栈实现队列`

#### 84. [largest rectangle in histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

> 思考一下这个题目和 [container with most water]( https://leetcode-cn.com/problems/container-with-most-water/ ) 有何差别？
>
> 差别在于这个题目的高度是指所有柱子中最低的高度，而 [container with most water]( https://leetcode-cn.com/problems/container-with-most-water/ ) 则是左右两边最小的高度。
>
> 1.暴力解法 O(n^3)
>
> ```java
> for i -> 0, n-2
>     for j -> i+1, n-1
>         (i, j) -> 最小高度， area
>         update max-area
> ```
>
> 2.`暴力加速`
>
> ```java
> for i -> 0, n-1
>     找到 left bound, right bound   // 固定中间一个高度，找到左右两边比他小的最小值
>     area = height[i] * (right - left)
>     update max-area
> ```
>
> 3.`Stack：有序栈(单调栈)找左右边界`   `#单调栈`
>
> 维护一个从小到大的有序栈
>
> 那么左边界left bound在栈里，而右边界则是比栈顶元素小的新元素
>
> 如果新元素的值大于栈顶元素，说明栈顶元素的右边界没有找到。
>
> 构造这个有序栈的过程，其实就是不断找到栈顶元素的右边界的过程（左边界在栈里）。

### Queue

#### 239. [sliding window maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)

> 1.暴力 O(n*k)
>
> 2.`deque O(n)` 滑动窗口 -> 队列        `#单调队列`

### Hash Table

#### [242. valid anagram](https://leetcode-cn.com/problems/valid-anagram/description/)  

> `#切题四件套`
>
> clarification
>
> -确定异位词是什么意思？
>
> -确定大小写是否敏感？
>
> 方法1：
>
> 暴力 sort -> sorted_str 是否相等？ O(NlogN)
>
> 方法2：哈希表 
>
> 统计每个字符出现的频次
>
> （1）第一个string，碰到字母加1，第二个string，碰到同样的字母减1，最后看map是否为空
>
> （2）int[256] 的数组，ascii -> index

#### [49.group anagrams](https://leetcode-cn.com/problems/group-anagrams/)

### Tree

#### [94. binary tree inorder traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

#### [98. validate binary search tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)

> 中序遍历是递增的。

### Recursion

#### [70. climbing stairs](https://leetcode-cn.com/problems/climbing-stairs/)

> 找 `最近重复性`
>
> 1: 1
>
> 2: 2
>
> 3: f(1) + f(2) 1的总的走法，跨2步走上3 + 2的总的走法，跨1步走上3 mutual exclusive, complete exhaustive
>
> 4: f(2) + f(3)
>
> ...
>
> n: f(n) = f(n-1) + f(n-2)  Fibonacci

```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;
        return climbStairs(n-1) + climbStairs(n-2);
    }
}
```

#### [22. generate parenthess * ](https://leetcode-cn.com/problems/generate-parentheses/)

```java
// 递归模板
class Solution {
    public void generateParenthesis(int n) {
        generate(0, 2 * n, "");
    }
    
    private void generate(int level, int max, String s) {
        // terminator
        if (level >= max) {
            System.out.println(s);
            return; 
        }
        // process current logic
        String s1 = s + "(";
        String s2 = s + ")";
        // drill down
        generate(level + 1, max, s1);
        generate(level + 1, max, s2);
        // reverse states
    }
}

// 检查括号合法性
// left 随时加，只要不超标 n
// right 左括号个数 > 右括号个数
class Solution {
    List<String> result;
    
    public List<String> generateParenthesis(int n) {
        result = new ArrayList<>();
        generate(0, 0, n, "");
    }
    
    private void generate(int left, int right, int n, String s) {
        // terminator
        if (left == n && right == n) {
            result.add(s);
            return; 
        }
        // process current logic
        String s1 = s + "(";
        String s2 = s + ")";
        // drill down
        if (left < n) {
            generate(left + 1, right, n, s1);
        }
        if (left > right) {
            generate(left, right + 1, n, s2);
        }
        generate(level + 1, max, s1);
        generate(level + 1, max, s2);
        // reverse states
    }
}
// 本质就是DFS
```

### Divide and conquer

#### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

> 1.暴力 O(n)
>
> ```java
> result = 1;
> for (int i = 0; i < n; i++) {
>     result *= x;
> }
> ```
>
> 2.分治 O(logn)
>
> `template`: 1. terminator 2. process (`divide` your big problem) 3. drill down (`conquer` your subproblems ) 4. `merge` sub result 5. reverse states. 
>
> ```java
> pow(x, n):
> 	subproblem: subresult = pow(x, n/2);
> 	mege:
> 		if (n % 2 == 1) {
>         	result = subresult * subresult * x;
>         } else {
>             result = subresult * subresult;
>         } 
> ```

#### [78. subsets](https://leetcode-cn.com/problems/subsets/) * 

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> ans = new ArrayList<>();
    if (nums == null) return ans;
    dfs(ans, nums, new ArrayList<Integer>(), 0);
    return ans;
}

private void dfs(List<List<Integer>> ans, int[] nums, List<Integer> list, int index) {
    // terminator
    if (index == nums.length) {
        ans.add(new ArrayList<Integer>(list));
        return;
    }
    
    // not pick the number at this index
    dfs(ans, nums, list, index + 1);
    
    // pick the number at this index
    list.add(num[index]);
    dfs(ans, nums, list, index + 1);
    
    // reverse the current state
    list.remove(list.size() - 1);
}

// or
private void dfs(List<List<Integer>> ans, int[] nums, List<Integer> list, int index) {
    // terminator
    if (index == nums.length) {
        ans.add(new ArrayList<Integer>(list));
        return;
    }
    
    // not pick the number at this index
    dfs(ans, nums, list.clone, index + 1);
    
    // pick the number at this index
    list.add(num[index]);
    dfs(ans, nums, list.clone, index + 1);
    
    // reverse the current state
}
```

```python
class Solution(object):
    def subsets(self, nums):
        result =[[]]
        for num in nums:
            newsets = []
            for subset in result:
                new_subset = subset + [num]
                newsets.append(new_subset)
           	result.extend(newsets) 
       	return result
```

#### [169. majority element](https://leetcode-cn.com/problems/majority-element/description/)

#### [17. letter combinations of a phone number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/) * 

```java
public List<String> letterCombination(String digits) {
    if (digits == null || digits.length() == 0) {
        return new ArrayList();
    }
    Map<Character, String> map = new HashMap<>();
    map.put('2', "abc");
    map.put('3', "def");
 	map.put('4', "ghi");
    map.put('5', "jkl");
    map.put('6', "mno");
    map.put('7', "pqrs");
    map.put('8', "tuv");
    map.put('9', "wxyz");   
    List<String> res = new ArrayList<>();
    search("", digits, 0, res, map);
    return res;
}

private void search(String s, 
                    String digits, 
                    int i, // level
                   List<String> res,
                   Map<Character, String> map) {
	// terminator
    if (i == digits.length) {
        res.add(s);
        return;
    }
    // process
    String letters = map.get(digits.charAt(i));
    for (int j = 0;  j < letters.length(); j++) {
        // drill down
        search(s+letters.charAt(j), digits, i+1, res, map);
    }
}
```

#### [51. n queens](https://leetcode-cn.com/problems/n-queens/)

```python
def sovleNQueen(self, n):
    if n < 1: return []
    self.result = []
    
    # 之前的皇后所攻击的位置(列，pie, na)
    self.cols = set();
    self.pie = set();
    self.na = set();
    
    self.DFS(n, 0, [])
    return self._generate_result(n)

def DFS(self, n, row, cur_state):
    # ternimator
    if row >= n:
        self.result.append(cur_state)
        return 
    
    # current level! Do it!
    for col in range(n):  # 遍历列 column
        if col in self.cols or row + col in self.pie or row - col in self.na:
            # go die
            continue
   		
        # update the flags
        self.cols.add(col)
        self.pie.add(row+col)
        self.na.add(row-col)
        
        self.DFS(n, row + 1, cur_state + [col])
        
        # reverse state
        self.cols.remove(col)
        self.pie.remove(row+col)
        self.na.remove(row-col)
       
def _generate_result(self, n):
    board = []
    for res in self.result:
        for i in res:
            board.append("." * i + "." * (n - i - 1))
    return [board[i: i + n] for i in range(0, len(board), n)]
        
```



### Binary Search

#### [69. sqrtx](https://leetcode-cn.com/problems/sqrtx/)

```java
class Solution {
    public int mySqrt(int x) {
        if (x == 0 || x == 1) {
            return x;
        }
        long left = 1;
        long right = x / 2; // (x/2)^2 >= x
        while (left < right) {
            long mid = left + (right - left + 1) / 2;
            if (mid * mid > x) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        return (int)left;
    }
}
```

* 扩展阅读：[牛顿迭代法](https://www.beyond3d.com/content/articles/8/)

#### [33. search in rotated sorted array](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

> 1.暴力遍历 O(N)
>
> 2.还原O(log N) -> 升序 -> 二分查找O(log N)
>
> 3.二分查找O(log N)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[0] <= nums[mid] && (target > nums[mid] || target < nums[0])) {
                left = mid + 1;
            } else if (target > nums[mid] && target < nums[0]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left == right && nums[left] == target ? left : -1;
    }
}
```



### BFS & DFS

#### [102. binary tree level order traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/#/description)

> 1.BFS
>
> 2.DFS

#### [22. generate parenthess * ](https://leetcode-cn.com/problems/generate-parentheses/)

> DFS

#### [200. number of islands](https://leetcode-cn.com/problems/number-of-islands/)

> floodfill

```java
class Solution {
    int[] dx = new int[]{-1, 1, 0, 0};
    int[] dy = new int[]{0, 0, -1, 1};
    char[][] g;
    
    public int numIslands(char[][] grid) {
    	int islands = 0;
        g = grid;
        for (int i = 0;  i < g.length; i++) {
            for (int j = 0; j < g[i].length; j++) {
                if (g[i][j] == '0') continue;
                islands += sink(i, j);
            }
        }
        return islands;
    }
    
    private int sink(int i, int j) {
        if (g[i][j] == '0') {
            return 0;
        }
        
        g[i][j] = '0';
        
        for (int k = 0; k < dx.length; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            if (x >= 0 && x < g.length && y >= 0 && y < g[x].length) {
                if (g[x][y] == '0') continue;
                sink(x, y);
            }
        }
        
        return 1;
    }
}
```

### Greedy

> 从后往前
>
> 从前往后
>
> 从某个点切入往某一边

#### [455. assign cookies]( https://leetcode-cn.com/problems/assign-cookies/ )

#### [122. best time to buy and sell stock ii](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

#### [55. jump game](https://leetcode-cn.com/problems/jump-game/)

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums == null) {
            return false;
        }
        
        int endReachable = nums.length - 1;
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] + i >= endReachable) {
                endReachable = i;
            }
        }
        
        return endReachable == 0;
    }
}
```



### Dynamic Programming



#### [70. climbing stairs](https://leetcode-cn.com/problems/climbing-stairs/)

> 找 `最近重复性`
>
> 1: 1
>
> 2: 2
>
> 3: f(1) + f(2) 1的总的走法，跨2步走上3 + 2的总的走法，跨1步走上3 mutual exclusive, complete exhaustive
>
> 4: f(2) + f(3)
>
> ...
>
> n: f(n) = f(n-1) + f(n-2)  Fibonacci
>
> 问题：
>
> （1）可以走1,  2，3步，如何解决？easy    -> f(n) = f(n-1) + f(n-2) + f(n-3)
>
> （2）相邻2步的步伐不同，如何解决？ medium

```java
class Solution {
    public int climbStairs(int n) {
        if(n <= 2) return n;
        return climbStairs(n-1) + climbStairs(n-2);
    }
}
```



##### 小结：一维动态规划：Fibnacci

```java
# 递归：自顶向下 O(2^N)
int fib(int n) {
    if (n <= 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2); // 改进：return n <= 1 ? n : fib(n-1) + fib(n-2);
}

# 递归 + 备忘录 （记忆化搜索） O(N)
int fib(int n, int[] memo) {
    if (n <= 1) {
        return n;
    }
    if (memo[n] == 0) {
        memo[n] = fib(n-1, memo) + fib(n-2, memo);
    }
    return memo[n];
}

# 动态规划：自底向上 O(N)
int fib(int n) {
    int[] dp = new int[n];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
   
# 一维的Equation: f(n) = f(n-1) + f(n-2)
```



#### [62. unique paths](https://leetcode-cn.com/problems/unique-paths/)

> ```
> opt[i, j] = opt[i+1, j] + opt[i, j+1];
> if a[i, j] == '空地'：
>     opt[i, j] = opt[i+1, j] + opt[i, j+1];
> else: 
> 	opt[i, j] = 0;
> ```

```java
int countPaths(boolean[][] grid, int row, int col) {
    if (!validSqure(grid, row, col)) return 0;
    if (isAtEnd(grid, row, col)) return 1;
    return countPaths(grid, row + 1, col) + countPaths(grid, row, col+1);
} 

class Solution {
    // 二维DP数组
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
    
    // 一维DP数组：将每一行都压缩在固定的一行更新，更新m次
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j-1];
            }
        }
        return dp[n-1];
    }
}
```

#### [65. unique paths ii](https://leetcode-cn.com/problems/unique-paths-ii/submissions/)

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid[0].length;
        int[] dp = new int[n];
        dp[0] = 1;
        for (int[] row : obstacleGrid) {  // 注意这种写法
            for (int j = 0; j < n; j++) {  // 这里j一定要从0开始，因为row[0]可能是障碍物
                if (row[j] == 1) {
                    dp[j] = 0;
                } else if (j > 0){
                    dp[j] += dp[j-1];
                }
            }
        }
        return dp[n-1];
    }
}
```


#### [64. minimum path sum](https://leetcode-cn.com/problems/minimum-path-sum/submissions/)

```java
// 暴力解法
class Solution {
    public int minPathSum(int[][] grid) {
        return minPathSum(0, 0, grid);
    }

    private int minPathSum(int i, int j, int[][] grid) {
        if (i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
        if (i == grid.length - 1 && j == grid[0].length - 1) {
            return grid[i][j];
        }
        return grid[i][j] + Math.min(minPathSum(i+1, j, grid), minPathSum(i, j+1, grid));
    }
}

// 动态规划
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length <= 0 || grid[0].length <= 0) {
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        int[][] states = new int[m][n];
        int sum = 0;
        for (int j = 0; j < n; j++) {
            sum += grid[0][j];
            states[0][j] = sum;
        }
        sum = 0;
        for (int i = 0;  i < m; i++) {
            sum += grid[i][0];
            states[i][0] = sum;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                states[i][j] = grid[i][j] + Math.min(states[i][j-1], states[i-1][j]);
            }
        }
        return states[m-1][n-1];
    }
}
```

##### 小结：二维动态规划：Count the paths

```java
// 递归
int countPaths(boolean[][] grid, int row, int col) {
    if (!validSqure(grid, row, col)) return 0;
    if (isAtEnd(grid, row, col)) return 1;
    return countPaths(grid, row + 1, col) + countPaths(grid, row, col+1);
}

opt[i, j] = opt[i+1, j] + opt[i, j+1];
if a[i, j] == '空地'：
    opt[i, j] = opt[i+1, j] + opt[i, j+1];
else: 
	opt[i, j] = 0;

对比：
# 一维的Equation: f(n) = f(n-1) + f(n-2)
    
# 二维的Equation: opt[i, j] = opt[i+1, j] + opt[i, j+1];
```

#### [120. triangle](https://leetcode-cn.com/problems/triangle/description/) ([一个不错的分析过程](https://leetcode.com/problems/triangle/discuss/38735/Python-easy-to-understand-solutions-(top-down-bottom-up).))

> 1、brute-force 递归， n层： left or right: O(2^N)
>
> 2、DP
>
> a.  重复性 `problem(i, j) = min(sub(i+1, j) , sub(i+1, j+1)) + a[i][j]`
>
> b. 状态数组 `f(i, j) `
>
> c. DP方程 `f(i, j) = min(f(i+1, j) , f(i+1, j+1)) + a[i][j]`
>

```python
class Solution:
    def minimumTotal(self, triangle):
        """
        :type triangle: List[List[int]]
        :rtype: int
        """
        dp = triangle
        for i in range(len(triangle) - 2, -1, -1):
            for j in range(len(triangle[i])):
                dp[i][j] += min(dp[i+1][j], dp[i+1][j+1])
        print(triangle[0][0])
        return dp[0][0]
```

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] dp = new int[triangle.size() + 1];
        for (int i = triangle.size() - 1; i >= 0; i--) {
            for (int j = 0; j < triangle.get(i).size(); j++) {
                dp[j] = Math.min(dp[j], dp[j+1]) + triangle.get(i).get(j);
            }
        }
        return dp[0];
    }
}
```

```java
class Solution {
    int maxRow;
    public int minimumTotal(List<List<Integer>> triangle) {
		maxRow = triange.size();
        return helper(0, 0, triangle);
    }
    
    private int helper(int row, int col, List<List<Integer>> triangle) {
        if (row == maxRow-1) {
            return triangle.get(row).get(col);
        }
        int left = helper(row+1, col, triangle);
        int right = helper(row+1, col+1, triangle);
        return Math.min(left, right) + triangle.get(row).get(col);
    }
}
```

```java
class Solution {
    int maxRow;
    Integer[][] memo;
    public int minimumTotal(List<List<Integer>> triangle) {
		maxRow = triange.size();
        memo = new Integer[row][row];
        return helper(0, 0, triangle);
    }
    
    private int helper(int row, int col, List<List<Integer>> triangle) {
        if (memo[row][col] != null) {
            return memo[row][col];
        }
        if (row == maxRow-1) {
            return memo[row][col] = triangle.get(row).get(col);
        }
        int left = helper(row+1, col, triangle);
        int right = helper(row+1, col+1, triangle);
        return memo[row][col] = Math.min(left, right) + triangle.get(row).get(col);
    }
}
```



#### [53. maximum sum subarray](https://leetcode-cn.com/problems/maximum-subarray/)

> 1、暴力 O(N^2)
>
> 2、DP
>
> a. 重复性 max_sum(i) = Max(max_sum(i-1) , 0) + a[i]  max_sum(i) : 表示以第i个元素结尾（包含）的连续子数组最大和
>
> b. 状态数组 f(i)  
>
> c. DP方程 f(i) = max(f(i-1), 0) + a[i]

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        1. dp[i] = max(nums[i], nums[i] + dp[i-1])
        2. 最大子序列和 = 当前元素最大（之前元素和为负） 或者 包含之前+当前之后最大
        """
        dp = nums
        for i in range(1, len(nums)):
            dp[i] = max(0, dp[i-1]) + nums[i]
        return max(dp) 
```



#### [152. maximum product subarray](https://leetcode-cn.com/problems/maximum-product-subarray/description/)



#### [322. coin change]( https://leetcode-cn.com/problems/coin-change/description/ ) ([推荐题解](https://leetcode-cn.com/problems/coin-change/solution/ling-qian-dui-huan-by-leetcode/))

> 1、暴力递归
>
> 2、BFS
>
> 3、DP
>
> a. 重复性
>
> b. DP array
>
> c. DP equation:  f(n) = min{f(n-k), for k in [1, 2, 5]} + 1
>
> 
>
> 变形：若问`共有多少种组合方式`?
>
> 分析：这个问题就类似于爬楼梯问题，爬楼梯每次可以爬1阶，每次可以爬2阶，每次也可以爬5阶，问爬到11阶有多少种方式？（不同之处在于硬币[1,2,1]和[1,1,2]是一种情况，而爬楼梯则不是）

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        return coinChange(0, coins, amount);
    }
    
    private int coinChange(int index, int[] coins, int amount) {
        if (amount == 0) {
            return 0;
        }
        if (index < coins.length && amount > 0) {
            int maxVal = amount / coins[index];
            int minCost = Integer.MAX_VALUE;
            for (int x = 0; x <= maxVal; x++) {
                if (amount >= x * coins[index]) {
                    int res = coinChange(index+1, coins, amount - x * coins[index]);
                    if (res != -1) {
                        minCost = Math.min(minCost, res + x);
                    }
                }
            }
            return minCost == Integer.MAX_VALUE ? -1 : minCost;
        }
        return -1;
    }
}
```

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount <=0) return 0;
        return coinChange(coins, amount, new int[amount]);
    }
    
    private int coinChange(int[] coins, int remain, int[] count) {
        if (remain < 0) {
            return -1;
        }
        if (remain == 0) {
            return 0;
        }
        if (count[remain-1] != 0) {
            return count[remain-1];
        }
        int min = Integer.MAX_VALUE;
        for (int coin : coins) {
            int res = coinChange(coins, remain - coin, count);
            if (res >= 0 && res < min) {
                min = res + 1;
            }
        }
        count[remain - 1] = min == Integer.MAX_VALUE ? -1 : min;
        return count[remain - 1];
    }
}
```

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                	dp[i] = Math.min(dp[i], dp[i-coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```



#### [1143. longest common subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)

> `# 经验` 
>
> 1.对于2个字符串的比较，很多时候，我们会从字符串的尾部向前看。
>
> 2.对于2个字符串的变化问题，很多时候会表示成一个二维数组，行和列的元素分别是2个字符串的字符

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        int n = text1.length();
        int m = text2.length();
        int[][] dp = new int[n+1][m+1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (text1.charAt(i-1) == text2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[n][m];
    }
    
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1 == null || text2 == null) {
            return 0;
        }
        int n = text1.length();
        int m = text2.length();
        int[] dp = new int[m+1];
        for (int i = 1; i <= n; i++) {
            int temp = 0;  
            for (int j = 1; j <= m; j++) {
                int prev = temp;
                temp = dp[j];
                if (text1.charAt(i-1) == text2.charAt(j-1)) {
                    dp[j] = prev + 1;
                } else {
                    dp[j] = Math.max(dp[j], dp[j-1]) ;
                }
            }
        }
        return dp[m];
    }
}
```



#### [72. edit distance (莱文斯坦距离)](https://leetcode-cn.com/problems/edit-distance/)

```java
class Solution {
    // 单独处理空字符串的dp
    public int minDistance(String word1, String word2) {
        if (word1 == null || word2 == null) {
            return 0;
        }
        int n = word1.length();
        int m = word2.length();
        if (n == 0) {
            return m;
        } else if (m == 0) {
            return n;
        }
        int[][] dp = new int[n][m];
        for (int j = 0; j < m; j++) {
            if (word1.charAt(0) == word2.charAt(j)) dp[0][j] = j;
            else if (j != 0) dp[0][j] = dp[0][j-1] + 1;
            else dp[0][j] = 1;
        }
        for (int i = 0; i < n; i++) {
            if (word1.charAt(i) == word2.charAt(0)) dp[i][0] = i;
            else if (i != 0) dp[i][0] = dp[i-1][0] + 1;
            else dp[i][0] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (word1.charAt(i) == word2.charAt(j)) {
                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1]);
                } else {
                    dp[i][j] = min( dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[n-1][m-1];
    }
    // 统一处理空字符串的dp
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        int[][] dp = new int[n+1][m+1];
        for (int j = 0; j <= m; j++) {
            dp[0][j] = j;
        }
        for (int i = 0; i <= n; i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[n][m];
    }

    private int min(int x, int y, int z) {
        return Math.min(x, Math.min(y, z));
    }   
}
```

