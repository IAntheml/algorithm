# 刷题笔记

## 如何有效学习数据结构与算法？

### 如何精通一个领域？

* Chunk it up  切碎知识点

  将数据结构与算法的基本知识点分解开来，分解结果见：[数据结构与算法脑图]( http://naotu.baidu.com/file/cd094852bfc84ec5e1868867936451c3?token=ef906723267f2f9f )

* Deliberate Practicing 刻意练习

  对分解之后的知识点进行分解训练和反复练习。

  * 明白一个`原则`：基本功是区别业余和职业选手的根本，我们的目标是成为职业选手。

  * 明白一个`误区`：**刷一道算法题，刷一遍是完全不够的，需要一遍遍刷题**。
  * 明白一个`事实`：反复练习自己薄弱的地方，扩张舒适区，会让我们成长更快。 

* Feedback 反馈

  反馈对于学习的作用，主要是将揉碎的知识点再串联起来，形成体系结构，这样就建立了一个 `知识点-> 专项反复练习-> 建立知识体系`的学习闭环。

  * 即时反馈
  * 主动型反馈（自己去找）
    * 高手代码，例如 Github，LeetCode（题解、Discussion）
    * 第一视角直播
  * 被动式反馈（高手指点）
    * Code Review
    * 教练看你打，然后给你反馈

### 如何精通数据结构与算法呢？

> 如何反复刷题呢？答案是：五步刷题法，我们称为***五毒神掌***。

1. 刷题第***1***遍
   * 5分钟时间：读题+思考
   * 若5分钟思考不出来，直接看解法，要注意：**对每一道题目，思考和比较这个题的多种解法，最好是全部解法**
   * **背诵、默写好的解法**：这是积累代码能力的一个很好的办法。
2. 刷题第***2***遍
   * 马上自己写 -> LeetCode提交
   * **多种解法进行比较、体会 -> 优化**
3. 刷题第***3***遍
   * **一天后**，再重复做题
   * 针对不同解法的熟练程度 -> 对薄弱的地方进行专项练习
4. 刷题第***4***遍
   * **一周后**，反复回来练习相同的题目
5. 刷题第***5***遍
   * **面试前一周**进行恢复性训练。

> 如何刷一道题呢？ 答案是：**切题四件套**。

1.  Clarification: 多沟通，多思考，确保正确理解问题
2. Possible solutions: 思考关于这个题目的所有解法，比较其优劣，优化其性能
   * compare(time/space)
   * optimal(加强)：例如空间换时间、升维（一维到二维）
3. Coding: 就是不停的写，多写，提高Coding能力的唯一法宝
4. Test cases    

## 工具

* [visualgo](https://visualgo.net/zh)

* [bigocheatsheet](https://www.bigocheatsheet.com/)

## 刷题开始

### Array

#### 283. [move zeros]( https://leetcode-cn.com/problems/move-zeroes/ )

> 方法1：将所有的非零元素都填充到数组前侧，然后将0填充到数组后侧  `#双指针法`

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int lastNotZeroIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] != 0) {
                nums[lastNotZeroIndex++] = nums[i];
            }
        }
        
        for (int i = lastNotZeroIndex; i < nums.length; ++i) {
            nums[i] = 0;
        }
    }
}
```



> 方法2：一维数组的坐标转换  i, j  `#双指针法`
>
> 用 j 记录上一个可能为0的值的索引，用 i 遍历数组，当遇到不为0的值的时候，将该元素 num[i] 与 nums[j] 交换，保证 j 前面的元素均为非0值。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int lastZeroIndex = 0;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] != 0) {
                int temp = nums[i];
                nums[i] = nums[lastZeroIndex];
                nums[lastZeroIndex] = temp;
                lastZeroIndex++;
            }
        }
    }
}
```

#### 11. [container with most water]( https://leetcode-cn.com/problems/container-with-most-water/ )

> 思路：
>
> 1.`枚举`： left bar x, right bar y, (y - x) * min_height     O(n^2)    `#枚举`

```java
// 遍历数组的一个常见的办法:遍历左右边界，且左右边界不能重复
class Solution {
    public int maxArea(int[] a) {
        int max = 0
        for (int i = 0; < a.length - 1; ++i) {
            for (int j = i + 1; j < a.length; ++j) {
                int area = (j - i) * Math.min(a[i], a[j]);
                max = Math.max(max, area); 
            }
        }
        return max;
    }
}
```

> 2.`左右夹逼/双指针法`：左右边界 i, j, 向中间收敛                   `#双指针法：左右夹中间，中间到两边`

```java
// 遍历数组的一个常见的办法:遍历左右边界，且左右边界不能重复
class Solution {
    public int maxArea(int[] a) {
        int max = 0
        for (int i = 0, j = a.length - 1; i < j; ) {
            int minHeight = a[i] < a[j] ? a[i++] : a[j--];
            max = Math.max(max, (j - i + 1) * minHeight); 
        }
        return max;
    }
}
```

#### 70. [climbing stairs](https://leetcode-cn.com/problems/climbing-stairs/)

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n;
        int f1 = 1;
        int f2 = 2;
        int f3 = 3;
        for (int i = 3; i <= n; i++) {
            f3 = f1 + f2;
            f1 = f2;
            f2 = f1;
        }
        return f3;
    }
}
```

#### 1. [2sum](https://leetcode-cn.com/problems/two-sum/)

> 方法1：暴力解法 O(n^2)

```java
// 遍历数组的一个常见的办法:遍历左右边界，且左右边界不能重复
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length - 1; ++i) {
            for (int j = i + 1; j < nums.length; ++j) {
                if (nums[i] + nums[j] == target) {
					return new int[] {i, j};
                }
            }
        }
        return new int[2];
    }
}
```

> 方法2：两遍哈希表  
>
> 思想：空间换时间
>
> ***保持数组中的每个元素与其索引相互对应的最好方式是什么？ 哈希表。***
>
> 哈希表查找的时间复杂度为 O(1)。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            map.put(target - nums[i], i);
        }
        for (int i = 0; i < nums.length; ++i) {
            if (map.containsKey(nums[i]) && i != map.get(nums[i])) {
                return new int[] {i, map.get(nums[i])};
            }
        }
        return new int[2];
    } 
}
```

> 方法3：一遍哈希表
>
> 由于在遍历数组的过程中，可以回过头来查找哈希表中是否存储了目标元素的值，因此，没有必要遍历完整的数组将目标元素的值存储到哈希表中，可以边遍历边存储。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            int component = target - nums[i];
            if (map.containsKey(component)) {
                return new int[] {map.get(component), i};
            }
            map.put(nums[i], i);
        }
        return new int[2];
    } 
}
```



#### 15. [3sum](https://leetcode-cn.com/problems/3sum/)

> 思路：转化 a + b = -c
>
> 1.暴力解法：三重循环
>
> 2.HashMap
>
> 3.`左右夹逼/双指针法`，这种办法有时候需要排序。

### Linked List

#### 141.  [linked-list-cycle](https://leetcode.com/problems/linked-list-cycle) 

> 1.暴力解法：遍历链表，hash/set
>
> 2.`快慢指针 `                                                                            `#快慢指针法`



### Stack

#### 20. [valid parentheses](https://leetcode-cn.com/problems/valid-parentheses/description/)

> 为啥这个题目可以用栈解决？ 具有最近相关性
>
> 1.暴力解法：不断replace匹配的括号 -> "" O(n^2)
>
> a. (){}[]
>
> b.((({[]})))
>
> 2.Stack

#### 155. [min Stack](https://leetcode-cn.com/problems/min-stack/)

> `两个队列实现栈`
>
> `两个栈实现队列`

#### 84. [largest rectangle in histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

> 思考一下这个题目和 [container with most water]( https://leetcode-cn.com/problems/container-with-most-water/ ) 有何差别？
>
> 差别在于这个题目的高度是指所有柱子中最低的高度，而 [container with most water]( https://leetcode-cn.com/problems/container-with-most-water/ ) 则是左右两边最小的高度。
>
> 1.暴力解法 O(n^3)
>
> ```java
> for i -> 0, n-2
>     for j -> i+1, n-1
>         (i, j) -> 最小高度， area
>         update max-area
> ```
>
> 2.`暴力加速`
>
> ```java
> for i -> 0, n-1
>     找到 left bound, right bound   // 固定中间一个高度，找到左右两边比他小的最小值
>     area = height[i] * (right - left)
>     update max-area
> ```
>
> 3.`Stack：有序栈(单调栈)找左右边界`   `#单调栈`
>
> 维护一个从小到大的有序栈
>
> 那么左边界left bound在栈里，而右边界则是比栈顶元素小的新元素
>
> 如果新元素的值大于栈顶元素，说明栈顶元素的右边界没有找到。
>
> 构造这个有序栈的过程，其实就是不断找到栈顶元素的右边界的过程（左边界在栈里）。

### Queue

#### 239. [sliding window maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)

> 1.暴力 O(n*k)
>
> 2.`deque O(n)` 滑动窗口 -> 队列        `#单调队列`
